/*
 * File: fromIp.c
 *
 *
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is an S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_defines_Changes_BEGIN
  *        #define NAME 'replacement text' 
  *        %%% SFUNWIZ_defines_Changes_END
  *
  *   DO NOT change NAME--Change the 'replacement text' only.
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *  -------------------------------------------------------------------------
  * | See matlabroot/simulink/src/sfuntmpl_doc.c for a more detailed template |
  *  ------------------------------------------------------------------------- 
 * Created: Sun Mar 21 15:37:46 2010
 * 
 *
 */

#define S_FUNCTION_LEVEL 2
#define S_FUNCTION_NAME fromJoystick
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/* %%%-SFUNWIZ_defines_Changes_BEGIN --- EDIT HERE TO _END */
#define NUM_INPUTS           0

#define NUM_OUTPUTS          1
/* Output Port  0 */
#define OUT_PORT_0_NAME      y0
#define OUTPUT_0_WIDTH       3
#define OUTPUT_DIMS_0_COL    1
#define OUTPUT_0_DTYPE       uint8_T
#define OUTPUT_0_COMPLEX     COMPLEX_NO
#define OUT_0_FRAME_BASED    FRAME_NO
#define OUT_0_BUS_BASED      0
#define OUT_0_BUS_NAME       
#define OUT_0_DIMS           1-D
#define OUT_0_ISSIGNED        1
#define OUT_0_WORDLENGTH      8
#define OUT_0_FIXPOINTSCALING 1
#define OUT_0_FRACTIONLENGTH  3
#define OUT_0_BIAS            0
#define OUT_0_SLOPE           0.125

#define NPARAMS              2

/* Parameter  1 */
#define PARAMETER_0_NAME      P1
#define PARAMETER_1_DTYPE     int_T
#define PARAMETER_0_COMPLEX   REAL_NO
#define PARAM_DEF0(S) ssGetSFcnParam(S, 0)

#define PARAMETER_1_NAME      P2
#define PARAMETER_1_DTYPE     int_T
#define PARAMETER_1_COMPLEX   REAL_NO
#define PARAM_DEF1(S) ssGetSFcnParam(S, 1)

#define SAMPLE_TIME_0        INHERITED_SAMPLE_TIME
#define NUM_DISC_STATES      0
#define DISC_STATES_IC       [0]
#define NUM_CONT_STATES      0
#define CONT_STATES_IC       [0]

#define SFUNWIZ_GENERATE_TLC 1
#define SOURCEFILES "__SFB__"
#define PANELINDEX           6
#define USE_SIMSTRUCT        0
#define SHOW_COMPILE_STEPS   0                   
#define CREATE_DEBUG_MEXFILE 0
#define SAVE_CODE_ONLY       0
#define SFUNWIZ_REVISION     3.0
/* %%%-SFUNWIZ_defines_Changes_END --- EDIT HERE TO _BEGIN */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
#include "simstruc.h"
#include "tmwtypes.h"
#include "simstruc_types.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h> 

int preCount,totalCount;
int connects;
int socks;
int newsocks;
struct  sockaddr_in servs;
struct  sockaddr_in clients;
static char* lasts;



static int tryConnect()
{
    struct sockaddr_in cli_addr;
    int clilen = sizeof(cli_addr);
	listen(socks,5);
	newsocks = accept(socks, 
	(struct sockaddr *) &clients,&clilen);
	if (newsocks < 0) 
		return 0;
	else
	{
		return 1;
	}

}
static void error(char *msg)
{
    perror(msg);
}

/*====================*
 * S-function methods *
 *====================*/
/* Function: mdlInitializeSizes ===============================================
 * Abstract:
 *   Setup sizes of the various vectors.
 */
static void mdlInitializeSizes(SimStruct *S)
{
    
    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
    ssSetNumSFcnParams(S, NPARAMS);
     if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {
	 return; /* Parameter mismatch will be reported by Simulink */
     }

    ssSetNumContStates(S, NUM_CONT_STATES);
    ssSetNumDiscStates(S, NUM_DISC_STATES);

    if (!ssSetNumInputPorts(S, NUM_INPUTS)) return;

    if (!ssSetNumOutputPorts(S, NUM_OUTPUTS)) return;
    ssSetOutputPortWidth(S, 0, OUTPUT_0_WIDTH);
    ssSetOutputPortDataType(S, 0, SS_UINT8);
    ssSetOutputPortComplexSignal(S, 0, OUTPUT_0_COMPLEX);
    ssSetNumSampleTimes(S, 1);
    ssSetNumModes(S, 0);
    ssSetNumNonsampledZCs(S, 0);

    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
        ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
		     SS_OPTION_WORKS_WITH_CODE_REUSE));

}

/* Function: mdlInitializeSampleTimes =========================================
 * Abstract:
 *    Specifiy  the sample time.
 */
static void mdlInitializeSampleTimes(SimStruct *S)
{
    ssSetSampleTime(S, 0, SAMPLE_TIME_0);
    ssSetOffsetTime(S, 0, 0.0);
}

#define MDL_SET_OUTPUT_PORT_DATA_TYPE
static void mdlSetOutputPortDataType(SimStruct *S, int port, DTypeId dType)
{
    ssSetOutputPortDataType(S, 0, dType);
}

#define MDL_SET_DEFAULT_PORT_DATA_TYPES
static void mdlSetDefaultPortDataTypes(SimStruct *S)
{
   ssSetOutputPortDataType(S, 0, SS_DOUBLE);
}


#define MDL_START
static void mdlStart(SimStruct *S)
{
 
int i;


    const real_T  *pp1  = mxGetData(PARAM_DEF0(S));
    const real_T  *pp2  = mxGetData(PARAM_DEF1(S));
    int num=mxGetNumberOfElements(ssGetSFcnParam(S,0));
    char  *port;
    char  porttemp[20];
    int count,n,portno;
    portno= *pp1;
    printf("port:%d\n",portno);
    int yes=1; 

    struct sockaddr_in serv_addr,cli_addr;


  


    connects=0;
    socks = socket(AF_INET, SOCK_STREAM, 0);
    if (socks < 0) 
    printf("ERROR opening socket");
    bzero((char *) &serv_addr, sizeof(serv_addr));
    setsockopt(socks,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(yes));

    serv_addr.sin_family = AF_INET;
    serv_addr.sin_addr.s_addr = INADDR_ANY;
    serv_addr.sin_port = htons(portno);

    if (bind(socks, (struct sockaddr *) &serv_addr,sizeof(serv_addr)) < 0) 
    printf("ERROR on binding");

    
    fcntl(socks, F_SETFL, O_NONBLOCK); 
    lasts =  malloc(3);

}





/* Function: mdlOutputs =======================================================
 *
*/
static void mdlOutputs(SimStruct *S, int_T tid)
{		

uint8_T        *y0  = (uint8_T *)ssGetOutputPortRealSignal(S,0);
    const int_T   y_width = 3;
 char* buffer[1];int i;

    if(connects==1)
    { 
        fcntl(newsocks, F_SETFL, O_NONBLOCK);
        if(recv(newsocks,buffer, 1, MSG_PEEK)>0)
        {
            read(newsocks,lasts,y_width);
            /*for(i=0;i< y_width;i++)
                printf("%i",lasts[i]);
            printf("\n");*/
       }
    }
        else
        {
            connects=tryConnect();
            if (connects)
                printf("Connected To Client\n");
        }
       /* fflush(stdout);*/
        for(i=0;i<y_width;i++)
           y0[i]=lasts[i];


        totalCount++;
}



/* Function: mdlTerminate =====================================================
 * Abstract:
 *    In this function, you should perform any actions that are necessary
 *    at the termination of a simulation.  For example, if memory was
 *    allocated in mdlStart, this is the place to free it.
 */
static void mdlTerminate(SimStruct *S)
{
  close(newsocks);  	
  close(socks);

}
#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
#include "simulink.c"      /* MEX-file interface mechanism */
#else
#include "cg_sfun.h"       /* Code generation registration function */
#endif



