/*
 * File: ardController.c
 *
 *
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is an S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_defines_Changes_BEGIN
  *        #define NAME 'replacement text' 
  *        %%% SFUNWIZ_defines_Changes_END
  *
  *   DO NOT change NAME--Change the 'replacement text' only.
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *  -------------------------------------------------------------------------
  * | See matlabroot/simulink/src/sfuntmpl_doc.c for a more detailed template |
  *  ------------------------------------------------------------------------- 
 * Created: Tue Aug  3 15:55:41 2010
 * 
 *
 */
#define S_FUNCTION_LEVEL 2
#define S_FUNCTION_NAME ardController
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/* %%%-SFUNWIZ_defines_Changes_BEGIN --- EDIT HERE TO _END */
#define NUM_INPUTS          1
/* Input Port  0 */
#define IN_PORT_0_NAME      u0
#define INPUT_0_WIDTH       DYNAMICALLY_SIZED
#define INPUT_DIMS_0_COL    1
#define INPUT_0_DTYPE       real_T
#define INPUT_0_COMPLEX     COMPLEX_NO
#define IN_0_FRAME_BASED    FRAME_NO
#define IN_0_BUS_BASED      0
#define IN_0_BUS_NAME       
#define IN_0_DIMS           1-D
#define INPUT_0_FEEDTHROUGH 1
#define IN_0_ISSIGNED        0
#define IN_0_WORDLENGTH      8
#define IN_0_FIXPOINTSCALING 1
#define IN_0_FRACTIONLENGTH  9
#define IN_0_BIAS            0
#define IN_0_SLOPE           0.125

#define NUM_OUTPUTS          1
/* Output Port  0 */
#define OUT_PORT_0_NAME      y0
#define OUTPUT_0_WIDTH       DYNAMICALLY_SIZED
#define OUTPUT_DIMS_0_COL    1
#define OUTPUT_0_DTYPE       real_T
#define OUTPUT_0_COMPLEX     COMPLEX_NO
#define OUT_0_FRAME_BASED    FRAME_NO
#define OUT_0_BUS_BASED      0
#define OUT_0_BUS_NAME       
#define OUT_0_DIMS           1-D
#define OUT_0_ISSIGNED        1
#define OUT_0_WORDLENGTH      8
#define OUT_0_FIXPOINTSCALING 1
#define OUT_0_FRACTIONLENGTH  3
#define OUT_0_BIAS            0
#define OUT_0_SLOPE           0.125

#define NPARAMS              3

#define PARAMETER_0_NAME      P1
#define PARAMETER_0_DTYPE     char_T
#define PARAMETER_0_COMPLEX   REAL_NO
#define PARAMETER_0_WIDTH     DYNAMICALLY_SIZED




#define SAMPLE_TIME_0        INHERITED_SAMPLE_TIME
#define NUM_DISC_STATES      0
#define DISC_STATES_IC       [0]
#define NUM_CONT_STATES      0
#define CONT_STATES_IC       [0]

#define SFUNWIZ_GENERATE_TLC 1
#define SOURCEFILES "__SFB__"
#define PANELINDEX           6
#define USE_SIMSTRUCT        0
#define SHOW_COMPILE_STEPS   0                   
#define CREATE_DEBUG_MEXFILE 0
#define SAVE_CODE_ONLY       0
#define SFUNWIZ_REVISION     3.0

#include "simstruc.h"


static void mdlInitializeSizes(SimStruct *S)
{

    DECL_AND_INIT_DIMSINFO(inputDimsInfo);
    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
    ssSetNumSFcnParams(S, NPARAMS);
     if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {
	 return; /* Parameter mismatch will be reported by Simulink */
     }

    ssSetNumContStates(S, NUM_CONT_STATES);
    ssSetNumDiscStates(S, NUM_DISC_STATES);

    if (!ssSetNumInputPorts(S, NUM_INPUTS)) return;
    inputDimsInfo.width = INPUT_0_WIDTH;
    ssSetInputPortDimensionInfo(S, 0, &inputDimsInfo);
    ssSetInputPortFrameData(S, 0, IN_0_FRAME_BASED);
    ssSetInputPortDataType(S, 0, SS_DOUBLE);
    ssSetInputPortComplexSignal(S, 0, INPUT_0_COMPLEX);
    ssSetInputPortDirectFeedThrough(S, 0, INPUT_0_FEEDTHROUGH);
    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/

 
    if (!ssSetNumOutputPorts(S, NUM_OUTPUTS)) return;

    outputDimsInfo.width =OUTPUT_0_WIDTH;
    ssSetOutputPortDimensionInfo(S, 0, &outputDimsInfo);
    ssSetOutputPortFrameData(S, 0, OUT_0_FRAME_BASED);
    ssSetOutputPortDataType(S, 0, SS_DOUBLE);
    ssSetOutputPortComplexSignal(S, 0, OUTPUT_0_COMPLEX);
    ssSetOutputPortComplexSignal(S, 0, OUTPUT_0_COMPLEX);
    ssSetNumSampleTimes(S, 1);
    ssSetNumRWork(S, 0);
    ssSetNumIWork(S, 0);
    ssSetNumPWork(S, 0);
    ssSetNumModes(S, 0);
    ssSetNumNonsampledZCs(S, 0);
    /*ssSetOutputPortWidth(S,0,atoi(temp));*/
    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
    ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
                     SS_OPTION_USE_TLC_WITH_ACCELERATOR | 
		     SS_OPTION_WORKS_WITH_CODE_REUSE
            | SS_OPTION_ALLOW_PARTIAL_DIMENSIONS_CALL));
}
#if defined(MATLAB_MEX_FILE)
#define MDL_SET_INPUT_PORT_DIMENSION_INFO
static void mdlSetInputPortDimensionInfo(SimStruct        *S,
                                  int_T            port,
                                  const DimsInfo_T *dimsInfo)
{
    if(!ssSetInputPortDimensionInfo(S, port, dimsInfo)) return;
}
#endif


#if defined(MATLAB_MEX_FILE)
#define MDL_SET_OUTPUT_PORT_DIMENSION_INFO
static void mdlSetOutputPortDimensionInfo(SimStruct        *S,
                                  int_T            port,
                                  const DimsInfo_T *dimsInfo)
{
    if(!ssSetOutputPortDimensionInfo(S, port, dimsInfo)) return;
}
#endif


# define MDL_SET_INPUT_PORT_FRAME_DATA
static void mdlSetInputPortFrameData(SimStruct  *S, 
                                     int_T      port,
                                     Frame_T    frameData)
{
    ssSetInputPortFrameData(S, port, frameData);
}
/* Function: mdlInitializeSampleTimes =========================================
 * Abstract:
 *    Specifiy  the sample time.
 */
static void mdlInitializeSampleTimes(SimStruct *S)
{
    ssSetSampleTime(S, 0, SAMPLE_TIME_0);
    ssSetOffsetTime(S, 0, 0.0);
}

#define MDL_SET_INPUT_PORT_DATA_TYPE
static void mdlSetInputPortDataType(SimStruct *S, int port, DTypeId dType)
{
    ssSetInputPortDataType( S, 0, dType);
}
#define MDL_SET_OUTPUT_PORT_DATA_TYPE
static void mdlSetOutputPortDataType(SimStruct *S, int port, DTypeId dType)
{
    ssSetOutputPortDataType(S, 0, dType);
}

#define MDL_SET_DEFAULT_PORT_DATA_TYPES
static void mdlSetDefaultPortDataTypes(SimStruct *S)
{
  ssSetInputPortDataType( S, 0, SS_DOUBLE);
  ssSetOutputPortDataType(S, 0, SS_DOUBLE);
}
# define MDL_SET_DEFAULT_PORT_DIMENSION_INFO
/* Function: mdlSetDefaultPortDimensionInfo ====================================
 *    This routine is called when Simulink is not able to find dimension
 *    candidates for ports with unknown dimensions. This function must set the
 *    dimensions of all ports with unknown dimensions.
 */
static void mdlSetDefaultPortDimensionInfo(SimStruct *S)
{
    char temp[3];
    int i;
    char* pp2=(char*)mxGetPr(ssGetSFcnParam(S,1));
    int param_width2=mxGetNumberOfElements(ssGetSFcnParam(S,1));  
    char* pp3=(char*)mxGetPr(ssGetSFcnParam(S,2));
    int param_width3=mxGetNumberOfElements(ssGetSFcnParam(S,2));  
    
    memset(temp, 0,3* sizeof(char));
    for (i=0;i<param_width2;i++)
        temp[i]=pp2[i*2];
    if( atoi(temp)<=0)
    {

        if(!ssSetInputPortMatrixDimensions(S, 0, 1, 1)) return;
    }
    else
    {
        /*if(!ssSetInputPortMatrixDimensions(S, 0, 1, atoi(temp))) return;remove?*/
    }
        
    memset(temp, 0,3* sizeof(char));
    for (i=0;i<param_width3;i++)	
	{
        temp[i]=pp3[i*2];
	printf("%c_",temp[i]);
}
    if( atoi(temp)>0)
    {

        if(!ssSetOutputPortMatrixDimensions(S, 0, 1, atoi(temp))) return;
    }
    else
    {
        if(!ssSetOutputPortMatrixDimensions(S, 0, 1, 1)) return;
    }

} /* end mdlSetDefaultPortDimensionInfo */

#ifdef _WIN32 || _WIN64/*If run for windows, do nothing (linux only)*/

static void mdlOutputs(SimStruct *S, int_T tid){}
static void mdlTerminate(SimStruct *S){}
#define MDL_START      
static void mdlStart(SimStruct *S){}
#else /*Running for linux*/ 

    int fd; /* File descriptor for the port */
    int lasts[20];/*Last values of pins, to check if resend if needed*/
    char prefix[20];/*Current configuration of each pin*/
    char conf[100];/*Input config message to be parsed*/
    char msg[100];/*Output config message to arduino (only pins to be polled are configed)*/
#include <stdio.h>    /* Standard input/output definitions */
#include <stdlib.h> 
#include <stdint.h>   /* Standard types */
#include <string.h>   /* String function definitions */
#include <unistd.h>   /* UNIX standard function definitions */
#include <fcntl.h>    /* File control definitions */
#include <errno.h>    /* Error number definitions */
#include <termios.h>  /* POSIX terminal control definitions */
#include <sys/ioctl.h>
#include <getopt.h>

/*====================*
 * S-function methods *
 *====================*/
/* Function: mdlInitializeSizes ===============================================
 * Abstract:
 *   Setup sizes of the various vectors.
 */

#define MDL_START      
static void mdlStart(SimStruct *S)
{
/*char* pp1Orig;=(char*)mxGetPr(ssGetSFcnParam(S,0));*/
int param_width1=mxGetNumberOfElements(ssGetSFcnParam(S,0));
int i,j,mod; 
char pp1[200];
/*Get the configuration parameter from simulink*/
    memset(pp1, 0,200* sizeof(char));
mxGetString(ssGetSFcnParam(S,0),pp1,param_width1+1);
  /*  if ((char)pp1Orig[i]=='[')*/
    /*{
    mod=2;
    for (i=0;i<param_width1*mod;i+=mod)
        pp1[i/mod]=(char)pp1Orig[i];

    }*/

    SS_SimMode mode= ssGetSimMode(S);
    if(mode!=0)
        goto OUT;
/*Setup USB serial connection*/
	/*The following lines are done automatically at startup due to installed usbHostConf scrip*/
    /*j=system("insmod /media/mmc2/usbserial.ko");
    j=system("insmod /media/mmc2/ftdi_sio.ko");
    j=system("echo host > /sys/devices/platform/musb_hdrc/mode");*/
    fd = open("/dev/ttyUSB0", O_RDWR | O_NOCTTY | O_NDELAY);
    if (fd == -1)
    {

	perror("open_port: Unable to open /dev/ttyUSB0 - ");
	fd = open("/dev/ttyUSB1", O_RDWR | O_NOCTTY | O_NDELAY);
	if (fd == -1)
	{
		perror("open_port: Unable to open /dev/ttyUSB1 - ");
	}
     }
	else
    fcntl(fd, F_SETFL, 0);
     struct termios options;
    if (tcgetattr(fd, &options) < 0) {
        perror("init_serialport: Couldn't get term attributes");
        goto OUT;
    }
    /*BAUD RATE SET, MUST MATCH ARDUINOS!!!*/
    cfsetispeed(&options, B115200);
    cfsetospeed(&options, B115200);
    /* 8N1*/
    options.c_cflag &= ~CSIZE; /* Mask the character size bits */
    options.c_cflag |= CS8;    /* Select 8 data bits */
	options.c_cflag &= ~PARENB;
	options.c_cflag &= ~CSTOPB;
    /* turn off HUPCL to avoid reset*/
    options.c_cflag &= ~HUPCL;
    /*no flow control*/
    /*options.c_cflag &= ~CRTSCTS;*/
    options.c_cflag |= (CLOCAL | CREAD);
    options.c_iflag &= ~(IXON | IXOFF | IXANY); /* turn off s/w flow ctrl*/
    options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG); /* make raw*/
    /* see: http://unixwiz.net/techtips/termios-vmin-vtime.html*/
    options.c_cc[VMIN]  = 0;
    options.c_cc[VTIME] = 20;    
    if( tcsetattr(fd, TCSANOW, &options) < 0) {
        perror("init_serialport: Couldn't set term attributes");
        goto OUT;
    }
    
    usleep(1000000);/*Pause for one second to assure connection*/
    /*END SERIAL LINE INTIALIZATION-------------------*/
    
    /*Clear arrays*/
    for(i=0;i<20;i++)
    {
        prefix[i]=0;
        lasts[i]=-999;
    }
    
    memset(conf, 0,100* sizeof(char));
    printf("width=%d\n",param_width1);
    printf("writing config-");
    for(i=0;i<param_width1;i++)
    {

	conf[i]=*(pp1+i);
        printf("%c",conf[i]);
    }
    printf("\n",*(pp1+i));
    fflush(stdout);
    
j=write(fd,"!!!!!!X",7);/*Flush out unfinished commands and reset conf*/
if (j < 0)
    fputs("write() of bytes failed!\n", stderr);
   
        j=write(fd,conf,param_width1);
        if (j < 0)
                fputs("write() of bytes failed!\n", stderr);



    for(i=0; i<param_width1/4;i++)/*parse through input config (each part is 4 chars)*/
    {
        int curIndex;
        curIndex=(*(pp1+i*4+3))-48 +((*(pp1+i*4+2))=='A')*14 ;
        /*printf("ind=%d\n",curIndex);*/
        fflush(stdout);
        prefix[(int)curIndex]=*(pp1+i*4+4);
        prefix[(int)curIndex]=*(pp1+i*4+4);
        /*printf("pref=%c\n",prefix[curIndex]);*/
    }

    OUT:;;
    
}

/* Function: mdlOutputs =======================================================
 *
*/
static void mdlOutputs(SimStruct *S, int_T tid)
{
    int param_width1=mxGetNumberOfElements(ssGetSFcnParam(S,0));
    const real_T       *pu0  = (const real_T*) ssGetInputPortSignal(S,0);
    real_T             *py0  = (real_T *)ssGetOutputPortRealSignal(S,0);
    const int_T        py_width = ssGetOutputPortWidth(S,0);
    const int_T        pu_width = ssGetInputPortWidth(S,0);

    int j,i,charPos=0,inPos=0,temp,tVal;
    char b[1];char tempBuf[5];
    memset(msg, 0,100* sizeof(char));

    /*Begin Write Block------------------------------*/
    msg[charPos++]='[';
    /*printf ("pow\n");
    for(i=0;i<%<pu_width>;i++)
    printf("ins= %d\n",((int)*%<pu0>+i));*/
    for(i=0;i<20;i++)
    {
        if((prefix[i]=='O' || prefix[i]=='P'|| prefix[i]=='M'|| prefix[i]=='T'|| prefix[i]=='S'))
        {
            
            temp=(int)(*(pu0+inPos));
            if(lasts[i]!=temp)
            {
            /*printf("pref=%c\n",prefix[i]);*/
            msg[charPos++]='W';
            if(prefix[i]=='O')
                msg[charPos++]='D';
            else 
                msg[charPos++]=prefix[i];

            msg[charPos++]=i+48;
            memcpy(msg+charPos,&temp, sizeof(int));/*integer-based value*/
            charPos+=sizeof(int);

            /*msg[charPos++]=(int)(*(%<pu0>+inPos));*/   
            lasts[i]=(int)(*(pu0+inPos));
            }
            inPos++;     

        }
    }  
    if(py_width>=1)/*If need to read*/
    {
        msg[charPos++]='R';/*Append a read all command at the end*/
        msg[charPos++]='+';    
        msg[charPos++]='0';    
        msg[charPos++]='0';
        msg[charPos++]='0';
        msg[charPos++]='0';
        msg[charPos++]='0';        
    }
    msg[charPos++]=']';
    if(charPos>2)
    {
	    printf("out=");
            for(i=0;i<charPos;i++)
            printf("%c",*(msg+i));
            printf("\n");
            j=write(fd,msg,charPos);
            if (j < 0)
                fputs("write() of bytes failed!\n", stderr);
    }
    /*End Write Block------------------------------*/
   
/*Begin Read Block------------------------------*/

if(py_width>=1)/*If need to read*/
{
    memset(msg, 0,100* sizeof(char));
    i=0;
    do { 
        j=read(fd, b, 1);  /* read a char at a time*/
        if( j==-1)
        {
            fputs("read of bytes failed!\n", stderr);

            goto OUT2;
        }
        if( j==0 ) {
            printf("Reconfiguring USB\n");
            j=write(fd,"!!!!!!X",7);
            j=write(fd,conf,param_width1);
            j=write(fd,"[R+00000]",9);
            i=0;
            goto OUT2;
        }
        msg[i] = b[0]; i++;
    } while( b[0] != ']');
    msg[i] = 0;  /* null terminate the string*/
    printf("msg=%s\n",msg+2);
    j=0;inPos=0;
    while(msg[j++]!='['){if (j>3)goto OUT2;}
    while(j<i-3)
    {
        temp=0;
        charPos=msg[j++]-48;
        memcpy(&tVal, msg+j, 4);
	   j+=4;
        if(charPos<=19 && inPos<py_width)
        *(py0+inPos)=(double)tVal;
        inPos++;
    }
}
OUT2:;;

}



/* Function: mdlTerminate =====================================================
 * Abstract:
 *    In this function, you should perform any actions that are necessary
 *    at the termination of a simulation.  For example, if memory was
 *    allocated in mdlStart, this is the place to free it.
 */
static void mdlTerminate(SimStruct *S)
{
    close(fd);
}

#endif

#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
#include "simulink.c"      /* MEX-file interface mechanism */


#else
#include "cg_sfun.h"       /* Code generation registration function */
#endif
