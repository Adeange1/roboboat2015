/*
 * File: picOut.c
 *
 *
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is an S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_defines_Changes_BEGIN
  *        #define NAME 'replacement text' 
  *        %%% SFUNWIZ_defines_Changes_END
  *
  *   DO NOT change NAME--Change the 'replacement text' only.
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *  -------------------------------------------------------------------------
  * | See matlabroot/simulink/src/sfuntmpl_doc.c for a more detailed template |
  *  ------------------------------------------------------------------------- 
 * Created: Tue Nov 17 23:26:19 2009
 * 
 *
 */
#if defined(MATLAB_MEX_FILE)
#include "tmwtypes.h"
#include "simstruc_types.h"
#else
#include "rtwtypes.h"
#endif

/* %%%-SFUNWIZ_wrapper_includes_Changes_BEGIN --- EDIT HERE TO _END */
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <jpeglib.h>
#include <fcntl.h>   /* File control definitions */
#include <termios.h> /* POSIX terminal control definitions */
#include <errno.h>
#include <netdb.h>


/* %%%-SFUNWIZ_wrapper_includes_Changes_END --- EDIT HERE TO _BEGIN */

#define allowed 60 
#define u_width 
#define y_width 320
/*
 * Create external references here.  
 *
 */
/* %%%-SFUNWIZ_wrapper_externs_Changes_BEGIN --- EDIT HERE TO _END */
/* extern double func(double a); */
int i,test,tries,failed,j,width,height,bytes_per_pixel, color_space,sockfd,len,result, jpglength;
struct sockaddr_in address;

int res; 
  long arg; 
  fd_set myset; 
  struct timeval tv; 
  int valopt; 
  socklen_t lon; 

FILE *fd;
char  *    ipaddr;
char  iptemp[100];
char *port;
char garbage1[80];
char garbage2[30];
char chbuffer[40000];
char      temp[20];
char      command[100];
struct addrinfo hints, *res2, *p;
    int status;
    char ipstr[INET6_ADDRSTRLEN];


#define S_FUNCTION_LEVEL 2
#define S_FUNCTION_NAME picOut
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/* %%%-SFUNWIZ_defines_Changes_BEGIN --- EDIT HERE TO _END */
#define NUM_INPUTS           0

#define NUM_OUTPUTS          3
/* Output Port  0 */
#define OUT_PORT_0_NAME      y0
#define OUTPUT_0_WIDTH       240
#define OUTPUT_DIMS_0_COL    320
#define OUTPUT_0_DTYPE       uint8_T
#define OUTPUT_0_COMPLEX     COMPLEX_NO
#define OUT_0_FRAME_BASED    FRAME_NO
#define OUT_0_BUS_BASED      0
#define OUT_0_BUS_NAME       
#define OUT_0_DIMS           2-D
#define OUT_0_ISSIGNED        1
#define OUT_0_WORDLENGTH      8
#define OUT_0_FIXPOINTSCALING 1
#define OUT_0_FRACTIONLENGTH  3
#define OUT_0_BIAS            0
#define OUT_0_SLOPE           0.125
/* Output Port  1 */
#define OUT_PORT_1_NAME      y1
#define OUTPUT_1_WIDTH       240
#define OUTPUT_DIMS_1_COL    320
#define OUTPUT_1_DTYPE       uint8_T
#define OUTPUT_1_COMPLEX     COMPLEX_NO
#define OUT_1_FRAME_BASED    FRAME_NO
#define OUT_1_BUS_BASED      0
#define OUT_1_BUS_NAME       
#define OUT_1_DIMS           2-D
#define OUT_1_ISSIGNED        1
#define OUT_1_WORDLENGTH      8
#define OUT_1_FIXPOINTSCALING 1
#define OUT_1_FRACTIONLENGTH  3
#define OUT_1_BIAS            0
#define OUT_1_SLOPE           0.125
/* Output Port  2 */
#define OUT_PORT_2_NAME      y2
#define OUTPUT_2_WIDTH       240
#define OUTPUT_DIMS_2_COL    320
#define OUTPUT_2_DTYPE       uint8_T
#define OUTPUT_2_COMPLEX     COMPLEX_NO
#define OUT_2_FRAME_BASED    FRAME_NO
#define OUT_2_BUS_BASED      0
#define OUT_2_BUS_NAME       
#define OUT_2_DIMS           2-D
#define OUT_2_ISSIGNED        1
#define OUT_2_WORDLENGTH      8
#define OUT_2_FIXPOINTSCALING 1
#define OUT_2_FRACTIONLENGTH  3
#define OUT_2_BIAS            0
#define OUT_2_SLOPE           0.125

#define NPARAMS              1
/* Parameter  1 */
#define PARAMETER_0_NAME      P1
#define PARAMETER_0_DTYPE     char_T
#define PARAMETER_0_COMPLEX   REAL_NO


#define SAMPLE_TIME_0        INHERITED_SAMPLE_TIME
#define NUM_DISC_STATES      0
#define DISC_STATES_IC       [0]
#define NUM_CONT_STATES      0
#define CONT_STATES_IC       [0]

#define SFUNWIZ_GENERATE_TLC 0
#define SOURCEFILES "__SFB__"
#define PANELINDEX           6
#define USE_SIMSTRUCT        0
#define SHOW_COMPILE_STEPS   0                   
#define CREATE_DEBUG_MEXFILE 0
#define SAVE_CODE_ONLY       0
#define SFUNWIZ_REVISION     3.0
/* %%%-SFUNWIZ_defines_Changes_END --- EDIT HERE TO _BEGIN */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
#include "simstruc.h"
#define PARAM_DEF0(S) ssGetSFcnParam(S, 0)

/* %%%-SFUNWIZ_defines_Changes_END --- EDIT HERE TO _BEGIN */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
#include "simstruc.h"



/*====================*
 * S-function methods *
 *====================*/
#define MDL_CHECK_PARAMETERS
 #if defined(MDL_CHECK_PARAMETERS) && defined(MATLAB_MEX_FILE)
   /* Function: mdlCheckParameters =============================================
     * Abstract:
     *    Validate our parameters to verify they are okay.
     */
    static void mdlCheckParameters(SimStruct *S)
    {
   
	return;
    }
 #endif /* MDL_CHECK_PARAMETERS */
/* Function: mdlInitializeSizes ===============================================
 * Abstract:
 *   Setup sizes of the various vectors.
 */
#define MDL_INITIAL_SIZES
static void mdlInitializeSizes(SimStruct *S)
{

    DECL_AND_INIT_DIMSINFO(outputDimsInfo);
    ssSetNumSFcnParams(S, NPARAMS);  /* Number of expected parameters */
      #if defined(MATLAB_MEX_FILE)
	if (ssGetNumSFcnParams(S) == ssGetSFcnParamsCount(S)) {
	  mdlCheckParameters(S);
	  if (ssGetErrorStatus(S) != NULL) {
	    return;
	  }
	 } else {
	   return; /* Parameter mismatch will be reported by Simulink */
	 }
      #endif

    ssSetNumContStates(S, NUM_CONT_STATES);
    ssSetNumDiscStates(S, NUM_DISC_STATES);

    if (!ssSetNumInputPorts(S, NUM_INPUTS)) return;

    if (!ssSetNumOutputPorts(S, NUM_OUTPUTS)) return;
    /* Output Port 0 */
    outputDimsInfo.width = OUTPUT_0_WIDTH;
    ssSetOutputPortDimensionInfo(S, 0, &outputDimsInfo);
    ssSetOutputPortMatrixDimensions( S ,0, OUTPUT_0_WIDTH, OUTPUT_DIMS_0_COL);
    ssSetOutputPortFrameData(S, 0, OUT_0_FRAME_BASED);
    ssSetOutputPortDataType(S, 0, SS_UINT8);
    ssSetOutputPortComplexSignal(S, 0, OUTPUT_0_COMPLEX);
    /* Output Port 1 */
    outputDimsInfo.width = OUTPUT_1_WIDTH;
    ssSetOutputPortDimensionInfo(S, 1, &outputDimsInfo);
    ssSetOutputPortMatrixDimensions( S ,1, OUTPUT_1_WIDTH, OUTPUT_DIMS_1_COL);
    ssSetOutputPortFrameData(S, 1, OUT_1_FRAME_BASED);
    ssSetOutputPortDataType(S, 1, SS_UINT8);
    ssSetOutputPortComplexSignal(S, 1, OUTPUT_1_COMPLEX);
    /* Output Port 2 */
    outputDimsInfo.width = OUTPUT_2_WIDTH;
    ssSetOutputPortDimensionInfo(S, 2, &outputDimsInfo);
    ssSetOutputPortMatrixDimensions( S ,2, OUTPUT_2_WIDTH, OUTPUT_DIMS_2_COL);
    ssSetOutputPortFrameData(S, 2, OUT_2_FRAME_BASED);
    ssSetOutputPortDataType(S, 2, SS_UINT8);
    ssSetOutputPortComplexSignal(S, 2, OUTPUT_2_COMPLEX);

    ssSetNumSampleTimes(S, 1);
    ssSetNumRWork(S, 0);
    ssSetNumIWork(S, 0);
    ssSetNumPWork(S, 0);
    ssSetNumModes(S, 0);
    ssSetNumNonsampledZCs(S, 0);

    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
    ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
		     SS_OPTION_WORKS_WITH_CODE_REUSE));
}


/* Function: mdlInitializeSampleTimes =========================================
 * Abstract:
 *    Specifiy  the sample time.
 */
#define MDL_INITIALIZE_SAMPLE_TIMES
static void mdlInitializeSampleTimes(SimStruct *S)
{
    ssSetSampleTime(S, 0, SAMPLE_TIME_0);
    ssSetOffsetTime(S, 0, 0.0);
}

#define MDL_SET_OUTPUT_PORT_DATA_TYPE
static void mdlSetOutputPortDataType(SimStruct *S, int port, DTypeId dType)
{
    ssSetOutputPortDataType(S, 0, dType);
}

#define MDL_SET_DEFAULT_PORT_DATA_TYPES
static void mdlSetDefaultPortDataTypes(SimStruct *S)
{
   ssSetOutputPortDataType(S, 0, SS_DOUBLE);
}



#define MDL_START
static void mdlStart(SimStruct *S)
{
    
    const int_T   p_width0  = mxGetNumberOfElements(PARAM_DEF0(S));
    /*const int_T   p_width1  = mxGetNumberOfElements(PARAM_DEF1(S));
    const int_T   p_width2  = mxGetNumberOfElements(PARAM_DEF2(S));
    const int_T   p_width3  = mxGetNumberOfElements(PARAM_DEF3(S));*/
    /*char*  *P1  = mxGetData(PARAM_DEF0(S));*/
     char* P1=mxGetPr(ssGetSFcnParam(S,0));
         int num=mxGetNumberOfElements(ssGetSFcnParam(S,0));
         int count;
         failed=0;   
    tries=0;
/*Determine Ip Address*/
    for(count=0;count<num;count++)
    {
        iptemp[count]=*(P1+count*2);
    }
    ipaddr=(char*)iptemp;
    
   /* getaddrinfo("n800.dnsalias.com",NULL, &hints, &servinfo);*/


    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;

    if ((status = getaddrinfo(ipaddr, NULL, &hints, &res2)) != 0) {
        fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(status));
        failed++;
        goto outStart;
    }
    perror("pow1\n");fflush(stderr);
    for(p = res2;p != NULL; p = p->ai_next) {
        void *addr;
        char *ipver;

        if (p->ai_family == AF_INET) {
            struct sockaddr_in *ipv4 = (struct sockaddr_in *)p->ai_addr;
            addr = &(ipv4->sin_addr);
            ipver = "IPv4";
        } else { 
            struct sockaddr_in6 *ipv6 = (struct sockaddr_in6 *)p->ai_addr;
            addr = &(ipv6->sin6_addr);
            ipver = "IPv6";
        }
        inet_ntop(p->ai_family, addr, ipstr, sizeof ipstr);
    }
    /*perror("pow2\n");fflush(stderr);
    fprintf(stderr,"IP=%s\n",ipstr); fflush(stderr);*/
    freeaddrinfo(res2);

    ipaddr=(char*)ipstr;
    port="8081";
   


  ;retry:;

  /*Create socket */
  sockfd = socket(AF_INET, SOCK_STREAM, 0); 

  /* Set non-blocking*/
  arg = fcntl(sockfd, F_GETFL, NULL); 
  arg |= O_NONBLOCK; 
  fcntl(sockfd, F_SETFL, arg); 

  /* Trying to connect with timeout */
  address.sin_family = AF_INET; 
  address.sin_port = htons(atoi(port)); 
  address.sin_addr.s_addr = inet_addr(ipaddr); 
  res = connect(sockfd, (struct sockaddr *)&address, sizeof(address)); 

  if (res < 0) { 
     if (errno == EINPROGRESS) { 
        tv.tv_sec = 5; 
        tv.tv_usec = 0; 
        FD_ZERO(&myset); 
        FD_SET(sockfd, &myset); 
        if (select(sockfd+1, NULL, &myset, NULL, &tv) > 0) { 
           lon = sizeof(int); 
           getsockopt(sockfd, SOL_SOCKET, SO_ERROR, (void*)(&valopt), &lon); 
           if (valopt) { 
              fprintf(stderr, "Error in connection() %d - %s\n", valopt, strerror(valopt)); 

              if(tries==0)
              {
              tries++;
              sprintf(command,"echo \"GET /cgi-bin/mjpg.cgi?start\" | telnet %s 80\n",ipaddr);
              system(command);
              sleep(3);
              goto retry;
              }
              else
              {
              failed++;
              goto outStart;
              }
           } 
        } 
        else { 
           fprintf(stderr, "Timeout or error() %d - %s\n", valopt, strerror(valopt)); 
           failed++;goto outStart;
        } 
     } 
     else { 
        fprintf(stderr, "Error connecting %d - %s\n", errno, strerror(errno)); 
        failed++;goto outStart;
     } 
  } 
  /* Set to blocking mode again... */
  arg = fcntl(sockfd, F_GETFL, NULL); 
  arg &= (~O_NONBLOCK); 
  fcntl(sockfd, F_SETFL, arg); 







/*	Now connect our socket to the server's socket.  */


	
	fd = fdopen(sockfd,"r");
	
	if(fd == NULL)
	{
		perror("oops: Cannot connect to Motion");
        failed++;
        perror("pow6\n");fflush(stderr);
        goto outStart;
	}

  ;outStart:;   
  

}
static void mdlOutputs(SimStruct *S, int_T tid)
{
    uint8_T        *y0  = (uint8_T *)ssGetOutputPortRealSignal(S,0);
    uint8_T        *y1  = (uint8_T *)ssGetOutputPortRealSignal(S,1);
    uint8_T        *y2  = (uint8_T *)ssGetOutputPortRealSignal(S,2);

 



if (failed>0)
goto out;

unsigned char *raw_image = NULL;    
    
/* dimensions of the image we want to write */

 
     /*	We can now read/write via sockfd.  */
    while(strncmp(garbage1,"Content-Length:",15)!=0)
	{
		fgets(garbage1, 70, fd);
	}

	
	sscanf(garbage1,"%s%d",garbage2,&jpglength);




	fgets(garbage1, 70, fd);
	
	fread(chbuffer, 1, jpglength, fd);
	/*
	printf("Content-Type: image/jpeg\n\n");*/
	 FILE *infile;
              infile = tmpfile ();
if ( !infile )
 {
  printf("Error opening jpeg file %s\n!", "out.jpg" );
goto out;
 }
    
    
	fwrite(chbuffer, 1, jpglength, infile);



rewind (infile);	

 struct jpeg_decompress_struct cinfo;
 struct jpeg_error_mgr jerr;
JSAMPROW row_pointer[1];

 unsigned long location = 0;

 /* here we set up the standard libjpeg error handler */
 cinfo.err = jpeg_std_error( &jerr );
 /* setup decompression process and source, then read JPEG header */
 jpeg_create_decompress( &cinfo );
 /* this makes the library read from infile */
 jpeg_stdio_src( &cinfo, infile );
 /* reading the image header which contains image information */
 jpeg_read_header( &cinfo, TRUE );
 /* Uncomment the following to output image information, if needed. */
/*
 printf( "JPEG File Information: \n" );
 printf( "Image width and height: %d pixels and %d pixels.\n", width=cinfo.image_width, height=cinfo.image_height );
 printf( "Color components per pixel: %d.\n", bytes_per_pixel = cinfo.num_components );
 printf( "Color space: %d.\n", cinfo.jpeg_color_space );
 */
 /* Start decompression jpeg here */
 jpeg_start_decompress( &cinfo );

 /* allocate memory to hold the uncompressed image */
 raw_image = (unsigned char*)malloc( cinfo.output_width*cinfo.output_height*cinfo.num_components );
 
/* now actually read the jpeg into the raw buffer */
 row_pointer[0] = (unsigned char *)malloc( cinfo.output_width*cinfo.num_components );


for( j=0; j<240;j++) 
 {
  jpeg_read_scanlines( &cinfo, row_pointer, 1 );
  for( i=0; i<320;i++) 
  {
        y0[j+i*240] = row_pointer[0][i*3];
        y1[j+i*240] = row_pointer[0][i*3+1];
        y2[j+i*240] = row_pointer[0][i*3+2];
  }
 }
 
 
 

 /* wrap up decompression, destroy objects, free pointers and close open files */
 jpeg_finish_decompress( &cinfo );
 jpeg_destroy_decompress( &cinfo );
 free( row_pointer[0] );
 fclose( infile );	
 free(raw_image);   
 ;out:;

if (failed>0)
{
    for( j=0; j<240;j++) 
    {
        for( i=0; i<320;i++) 
        {
            y0[j+i*240] = j%230;
            y1[j+i*240] = i%230;
            y2[j+i*240] = (i+j)%230;
        }
    }    
}

}



/* Function: mdlTerminate =====================================================
 * Abstract:
 *    In this function, you should perform any actions that are necessary
 *    at the termination of a simulation.  For example, if memory was
 *    allocated in mdlStart, this is the place to free it.
 */
#define MDL_TERMINATE
static void mdlTerminate(SimStruct *S)
{
    if (failed==0)
    {
             	fclose(fd);
	close(sockfd);	
    }
    
/*sprintf(command,"echo \"GET /cgi-bin/mjpg.cgi?stop\" | telnet %s 80\n",ipaddr);

printf("%s",command);
    
system(command);*/
    
}
#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
#include "simulink.c"      /* MEX-file interface mechanism */
#else
#include "cg_sfun.h"       /* Code generation registration function */
#endif


