/*
 * File: toIp.c
 *
 *
  *
  *   --- THIS FILE GENERATED BY S-FUNCTION BUILDER: 3.0 ---
  *
  *   This file is an S-function produced by the S-Function
  *   Builder which only recognizes certain fields.  Changes made
  *   outside these fields will be lost the next time the block is
  *   used to load, edit, and resave this file. This file will be overwritten
  *   by the S-function Builder block. If you want to edit this file by hand, 
  *   you must change it only in the area defined as:  
  *
  *        %%%-SFUNWIZ_defines_Changes_BEGIN
  *        #define NAME 'replacement text' 
  *        %%% SFUNWIZ_defines_Changes_END
  *
  *   DO NOT change NAME--Change the 'replacement text' only.
  *
  *   For better compatibility with the Real-Time Workshop, the
  *   "wrapper" S-function technique is used.  This is discussed
  *   in the Real-Time Workshop User's Manual in the Chapter titled,
  *   "Wrapper S-functions".
  *
  *  -------------------------------------------------------------------------
  * | See matlabroot/simulink/src/sfuntmpl_doc.c for a more detailed template |
  *  ------------------------------------------------------------------------- 
 * Created: Fri Dec  4 13:45:43 2009
 * 
 *
 */

#define S_FUNCTION_LEVEL 2
#define S_FUNCTION_NAME toIp
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
/* %%%-SFUNWIZ_defines_Changes_BEGIN --- EDIT HERE TO _END */
#define NUM_INPUTS          1
/* Input Port  0 */
#define IN_PORT_0_NAME      u0
#define INPUT_0_WIDTH       DYNAMICALLY_SIZED
#define INPUT_DIMS_0_COL    1
#define INPUT_0_DTYPE       uint8_T
#define INPUT_0_COMPLEX     COMPLEX_NO
#define IN_0_FRAME_BASED    FRAME_NO
#define IN_0_BUS_BASED      0
#define IN_0_BUS_NAME       
#define IN_0_DIMS           1-D
#define INPUT_0_FEEDTHROUGH 1
#define IN_0_ISSIGNED        0
#define IN_0_WORDLENGTH      8
#define IN_0_FIXPOINTSCALING 1
#define IN_0_FRACTIONLENGTH  9
#define IN_0_BIAS            0
#define IN_0_SLOPE           0.125

#define NUM_OUTPUTS          0
#define NPARAMS              2
/* Parameter  1 */
#define PARAMETER_0_NAME      P1
#define PARAMETER_0_DTYPE     char_T
#define PARAMETER_0_COMPLEX   REAL_NO

/* Parameter  1 */
#define PARAMETER_1_NAME      P2
#define PARAMETER_1_DTYPE     char_T
#define PARAMETER_1_COMPLEX   REAL_NO


#define SAMPLE_TIME_0        INHERITED_SAMPLE_TIME
#define NUM_DISC_STATES      0
#define DISC_STATES_IC       [0]
#define NUM_CONT_STATES      0
#define CONT_STATES_IC       [0]

#define SFUNWIZ_GENERATE_TLC 0
#define SOURCEFILES "__SFB__"
#define PANELINDEX           6
#define USE_SIMSTRUCT        0
#define SHOW_COMPILE_STEPS   0                   
#define CREATE_DEBUG_MEXFILE 0
#define SAVE_CODE_ONLY       0
#define SFUNWIZ_REVISION     3.0
/* %%%-SFUNWIZ_defines_Changes_END --- EDIT HERE TO _BEGIN */
/*<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<*/
#include "simstruc.h"
#define PARAM_DEF0(S) ssGetSFcnParam(S, 0)
#define PARAM_DEF1(S) ssGetSFcnParam(S, 1)
#include <sys/socket.h>       /*  socket definitions        */
#include <sys/types.h>        /*  socket types              */
#include <arpa/inet.h>        /*  inet (3) funtions         */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h> 
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h> 
#include <netdb.h> 


static int tryConnect(SimStruct *S)
{

    struct sockaddr_in *sAddr=(void*)ssGetPWorkValue(S, 0);
    int sockfd= ssGetIWorkValue(S, 1);

    if (connect(sockfd,sAddr,sizeof(*sAddr)  )< 0) 
    {
            
		return 0;
    }
	else
	{
		return 1;
	}

}
static void error(char *msg)
{
    perror(msg);
}

/*====================*
 * S-function methods *
 *====================*/
/* Function: mdlInitializeSizes ===============================================
 * Abstract:
 *   Setup sizes of the various vectors.
 */
static void mdlInitializeSizes(SimStruct *S)
{
  DECL_AND_INIT_DIMSINFO(inputDimsInfo);
  DECL_AND_INIT_DIMSINFO(outputDimsInfo);
    ssSetNumSFcnParams(S, NPARAMS);  /* Number of expected parameters */
    if (ssGetNumSFcnParams(S) != ssGetSFcnParamsCount(S)) {
	 return; /* Parameter mismatch will be reported by Simulink */
     }
    ssSetNumContStates(S, NUM_CONT_STATES);
    ssSetNumDiscStates(S, NUM_DISC_STATES);
    if (!ssSetNumInputPorts(S, NUM_INPUTS)) return;  
    ssSetInputPortDimensionInfo(S, 0, &inputDimsInfo);
    ssSetInputPortFrameData(S, 0, IN_0_FRAME_BASED);
    ssSetInputPortDataType(S, 0, SS_UINT8);
    ssSetInputPortComplexSignal(S, 0, INPUT_0_COMPLEX);
    ssSetInputPortDirectFeedThrough(S, 0, INPUT_0_FEEDTHROUGH);
    ssSetInputPortRequiredContiguous(S, 0, 1); /*direct input signal access*/

  
    ssSetNumSampleTimes(S, 1);
    ssSetNumRWork(S, 0);
    ssSetNumIWork(S, 3);
    ssSetNumPWork(S, 1);
    ssSetNumModes(S, 0);
    ssSetNumNonsampledZCs(S, 0);
    /* Take care when specifying exception free code - see sfuntmpl_doc.c */
    ssSetOptions(S, (SS_OPTION_EXCEPTION_FREE_CODE |
		     SS_OPTION_WORKS_WITH_CODE_REUSE));

    
}






#define MDL_SET_DEFAULT_PORT_DIMENSION_INFO
static void mdlSetDefaultPortDimensionInfo(SimStruct *S)
{
  DECL_AND_INIT_DIMSINFO(portDimsInfo);
  int_T dims[2] = { 1, 1 };
  bool  frame = (ssGetInputPortFrameData(S, 0) == FRAME_YES) ||
                  (ssGetOutputPortFrameData(S, 0) == FRAME_YES);

  /* Neither the input nor the output ports have been set */

  portDimsInfo.width   = 1;
  portDimsInfo.numDims = frame ? 2 : 1;
  portDimsInfo.dims    = frame ? dims : &portDimsInfo.width;

  if (ssGetInputPortNumDimensions(S, 0) == (-1)) {  
      ssSetInputPortDimensionInfo(S, 0, &portDimsInfo);
  }

  if (ssGetOutputPortNumDimensions(S, 0) == (-1)) {
      ssSetInputPortDimensionInfo(S, 0, &portDimsInfo);
  }
}
# define MDL_SET_INPUT_PORT_FRAME_DATA
static void mdlSetInputPortFrameData(SimStruct  *S, 
                                     int_T      port,
                                     Frame_T    frameData)
{
    ssSetInputPortFrameData(S, port, frameData);
}
/* Function: mdlInitializeSampleTimes =========================================
 * Abstract:
 *    Specifiy  the sample time.
 */
static void mdlInitializeSampleTimes(SimStruct *S)
{
    ssSetSampleTime(S, 0, SAMPLE_TIME_0);
    ssSetOffsetTime(S, 0, 0.0);
}

#define MDL_SET_INPUT_PORT_DATA_TYPE
static void mdlSetInputPortDataType(SimStruct *S, int port, DTypeId dType)
{
    ssSetInputPortDataType( S, 0, dType);
}
#define MDL_SET_OUTPUT_PORT_DATA_TYPE
static void mdlSetOutputPortDataType(SimStruct *S, int port, DTypeId dType)
{
    ssSetOutputPortDataType(S, 0, dType);
}

#define MDL_SET_DEFAULT_PORT_DATA_TYPES
static void mdlSetDefaultPortDataTypes(SimStruct *S)
{
  ssSetInputPortDataType( S, 0, SS_DOUBLE);
 ssSetOutputPortDataType(S, 0, SS_DOUBLE);
}




#define MDL_START      
static void mdlStart(SimStruct *S)
{
SS_SimMode mode= ssGetSimMode(S);
  if(mode==0)
  {


   struct hostent *server;
   struct sockaddr_in sAddr;

   typedef struct Color_tag {int r; int b; int g;} Color;


   int connected=0,sockfd,portno;
   char* P1=(char*)mxGetPr(ssGetSFcnParam(S,0));
   char* P2=(char*)mxGetPr(ssGetSFcnParam(S,1));
   int num=mxGetNumberOfElements(ssGetSFcnParam(S,0));
   int num2=mxGetNumberOfElements(ssGetSFcnParam(S,1));
     int count;
     char  *port,*ipaddr;
     char  porttemp[20];
     char  iptemp[100];
/*Determine Ip Address*/
for(count=0;count<num;count++)
    iptemp[count]=*(P1+count*2);
iptemp[num]=0;
ipaddr=(char*)iptemp;

/*Determine Port Number*/  
for(count=0;count<num2;count++)
    porttemp[count]=*(P2+count*2);
port=(char*)porttemp;

portno = atoi(port);
sockfd = socket(AF_INET, SOCK_STREAM, 0);
if (sockfd < 0) 
    printf("ERROR opening socket");


server = gethostbyname(ipaddr);
if (server == NULL) {
    printf("ERROR, no such host\n");
}
bzero((char *) &sAddr, sizeof(sAddr));
sAddr.sin_family = AF_INET;
bcopy((char *)server->h_addr, 
     (char *)&sAddr.sin_addr.s_addr,
     server->h_length);
sAddr.sin_port = htons(portno);
/* printf("~%i,%i\n",&sAddr,sAddr.sin_port);*/
ssSetIWorkValue(S, 0, connected);
ssSetIWorkValue(S, 1, sockfd);
ssSetIWorkValue(S, 2, 0);
struct sockaddr_in *copy=malloc(sizeof(sAddr));
*copy=sAddr;
     ssSetPWorkValue(S, 0, (void*) copy);


/*   printf("%i,%i,%i,%i\n",copy,&sAddr,copy->sin_port,sAddr.sin_port);*/


  }
}











/* Function: mdlOutputs =======================================================
 *
*/
static void mdlOutputs(SimStruct *S, int_T tid)
{
SS_SimMode mode= ssGetSimMode(S);
if(mode==0)
{
    const uint8_T   *u0  = (const uint8_T*) ssGetInputPortSignal(S,0);

    int connected=ssGetIWorkValue(S, 0);
 int i;
    int sockfd =ssGetIWorkValue(S, 1);
    const int_T        u_width = ssGetInputPortWidth(S,0);
	ssSetIWorkValue(S, 2, ssGetIWorkValue(S, 2)+1);
    if(connected==1 )
    {
        write(sockfd,u0,u_width);
    }
    else
    {
        connected=tryConnect(S);
        if (connected)
           printf("Connected To Server\n");
    }
    
    ssSetIWorkValue(S, 0, connected);
}
}



/* Function: mdlTerminate =====================================================
 * Abstract:
 *    In this function, you should perform any actions that are necessary
 *    at the termination of a simulation.  For example, if memory was
 *    allocated in mdlStart, this is the place to free it.
 */
static void mdlTerminate(SimStruct *S)
{
SS_SimMode mode= ssGetSimMode(S);
if(mode==0)
{
    struct sockaddr_in *sAddr=(void*)ssGetPWorkValue(S, 0);
    free(sAddr);
    int sockfd= ssGetIWorkValue(S, 1);
    close(sockfd);
}
}
#ifdef  MATLAB_MEX_FILE    /* Is this file being compiled as a MEX-file? */
#include "simulink.c"      /* MEX-file interface mechanism */
#else
#include "cg_sfun.h"       /* Code generation registration function */
#endif


